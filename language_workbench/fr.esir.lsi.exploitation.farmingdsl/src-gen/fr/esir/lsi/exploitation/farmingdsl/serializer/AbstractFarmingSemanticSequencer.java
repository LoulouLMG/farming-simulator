package fr.esir.lsi.exploitation.farmingdsl.serializer;

import activity.ActivityPackage;
import activity.Model;
import activity.PeriodicActivity;
import activity.Predicate;
import activity.ResourceAllocation;
import activity.ResourceType;
import activity.Rule;
import com.google.inject.Inject;
import com.google.inject.Provider;
import fr.esir.lsi.exploitation.farmingdsl.services.FarmingGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractFarmingSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FarmingGrammarAccess grammarAccess;
	
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == ActivityPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ActivityPackage.MODEL:
				if(context == grammarAccess.getModelRule()) {
					sequence_Model(context, (Model) semanticObject); 
					return; 
				}
				else break;
			case ActivityPackage.PERIODIC_ACTIVITY:
				if(context == grammarAccess.getPeriodicActivityRule()) {
					sequence_PeriodicActivity(context, (PeriodicActivity) semanticObject); 
					return; 
				}
				else break;
			case ActivityPackage.PREDICATE:
				if(context == grammarAccess.getPredicateRule()) {
					sequence_Predicate(context, (Predicate) semanticObject); 
					return; 
				}
				else break;
			case ActivityPackage.RESOURCE_ALLOCATION:
				if(context == grammarAccess.getResourceAllocationRule()) {
					sequence_ResourceAllocation(context, (ResourceAllocation) semanticObject); 
					return; 
				}
				else break;
			case ActivityPackage.RESOURCE_TYPE:
				if(context == grammarAccess.getResourceTypeRule()) {
					sequence_ResourceType(context, (ResourceType) semanticObject); 
					return; 
				}
				else break;
			case ActivityPackage.RULE:
				if(context == grammarAccess.getRuleRule()) {
					sequence_Rule(context, (Rule) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     ((ressourceTypes+=ResourceType ressourceTypes+=ResourceType*)? (activities+=PeriodicActivity activities+=PeriodicActivity*)?)
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         periodicity=EInt? 
	 *         start=EDate? 
	 *         end=EDate? 
	 *         (rules+=Rule rules+=Rule*)? 
	 *         (allocations+=ResourceAllocation allocations+=ResourceAllocation*)?
	 *     )
	 */
	protected void sequence_PeriodicActivity(EObject context, PeriodicActivity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {Predicate}
	 */
	protected void sequence_Predicate(EObject context, Predicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (resource=[ResourceType|EString] duration=EInt?)
	 */
	protected void sequence_ResourceAllocation(EObject context, ResourceAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_ResourceType(EObject context, ResourceType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ActivityPackage.Literals.RESOURCE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ActivityPackage.Literals.RESOURCE_TYPE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getResourceTypeAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((predicates+=Predicate predicates+=Predicate*)?)
	 */
	protected void sequence_Rule(EObject context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
